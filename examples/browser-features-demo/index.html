<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserGit - Browser Features & Performance Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .feature-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }

        .feature-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .feature-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-supported {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-not-supported {
            background: #ffebee;
            color: #c62828;
        }

        .browser-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .quota-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .quota-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #66BB6A);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #333;
        }

        .stat-unit {
            font-size: 14px;
            color: #999;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .performance-table th,
        .performance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .performance-table th {
            background: #f5f5f5;
            font-weight: 600;
            color: #333;
        }

        .performance-good {
            color: #2e7d32;
        }

        .performance-warning {
            color: #f57c00;
        }

        .performance-bad {
            color: #c62828;
        }

        .log {
            background: #263238;
            color: #aed581;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .recommendation {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
        }

        .recommendation h3 {
            color: #e65100;
            margin-bottom: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç BrowserGit Feature Detection & Performance Demo</h1>
            <p class="subtitle">Comprehensive browser compatibility and performance testing</p>
        </header>

        <div class="section">
            <h2>Browser Information</h2>
            <div class="browser-info" id="browser-info">
                <div>Loading browser information...</div>
            </div>
        </div>

        <div class="section">
            <h2>Feature Detection</h2>
            <div id="requirements"></div>
            <div class="feature-grid" id="features">
                <div>Detecting features...</div>
            </div>
        </div>

        <div class="section">
            <h2>Storage Quota</h2>
            <div id="storage-quota">
                <div>Checking storage quota...</div>
            </div>
        </div>

        <div class="section">
            <h2>Performance Benchmarks</h2>
            <button onclick="runPerformanceBenchmarks()">Run Benchmarks</button>
            <button onclick="clearPerformanceData()">Clear Data</button>
            <div id="performance-results"></div>
        </div>

        <div class="section">
            <h2>Recommendations</h2>
            <div id="recommendations">
                <div>Analyzing browser capabilities...</div>
            </div>
        </div>

        <div class="section">
            <h2>Activity Log</h2>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script type="module">
        // This would import from the actual package
        // For demo purposes, we'll simulate the APIs

        let logs = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${message}`;
            logs.push(entry);
            updateLog();
        }

        function updateLog() {
            const logEl = document.getElementById('log');
            logEl.innerHTML = logs.map(entry =>
                `<div class="log-entry">${entry}</div>`
            ).join('');
            logEl.scrollTop = logEl.scrollHeight;
        }

        // Detect browser
        function detectBrowser() {
            const ua = navigator.userAgent;
            let name = 'Unknown';
            let version = 'Unknown';

            if (ua.includes('Chrome') && !ua.includes('Edg')) {
                name = 'Chrome';
                const match = ua.match(/Chrome\/(\d+)/);
                if (match) version = match[1];
            } else if (ua.includes('Edg/')) {
                name = 'Edge';
                const match = ua.match(/Edg\/(\d+)/);
                if (match) version = match[1];
            } else if (ua.includes('Firefox')) {
                name = 'Firefox';
                const match = ua.match(/Firefox\/(\d+)/);
                if (match) version = match[1];
            } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                name = 'Safari';
                const match = ua.match(/Version\/(\d+)/);
                if (match) version = match[1];
            }

            return { name, version, platform: navigator.platform };
        }

        // Display browser info
        function displayBrowserInfo() {
            const browser = detectBrowser();
            document.getElementById('browser-info').innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                    <div><strong>Browser:</strong> ${browser.name}</div>
                    <div><strong>Version:</strong> ${browser.version}</div>
                    <div><strong>Platform:</strong> ${browser.platform}</div>
                </div>
            `;
            log(`Detected ${browser.name} ${browser.version} on ${browser.platform}`);
        }

        // Check features
        async function checkFeatures() {
            const features = {
                'WebAssembly': typeof WebAssembly !== 'undefined',
                'IndexedDB': typeof indexedDB !== 'undefined',
                'localStorage': typeof localStorage !== 'undefined',
                'SubtleCrypto': typeof crypto !== 'undefined' && 'subtle' in crypto,
                'CompressionStream': typeof CompressionStream !== 'undefined',
                'Web Workers': typeof Worker !== 'undefined',
                'SharedArrayBuffer': typeof SharedArrayBuffer !== 'undefined',
                'Storage Manager': 'storage' in navigator,
            };

            // Check OPFS
            try {
                if ('storage' in navigator && 'getDirectory' in navigator.storage) {
                    await navigator.storage.getDirectory();
                    features['OPFS'] = true;
                } else {
                    features['OPFS'] = false;
                }
            } catch {
                features['OPFS'] = false;
            }

            return features;
        }

        async function displayFeatures() {
            const features = await checkFeatures();
            const required = ['WebAssembly', 'SubtleCrypto'];
            const missing = required.filter(f => !features[f]);

            // Display requirements
            const reqEl = document.getElementById('requirements');
            if (missing.length === 0) {
                reqEl.innerHTML = '<div style="background: #e8f5e9; padding: 15px; border-radius: 4px; color: #2e7d32;">‚úÖ All minimum requirements are met</div>';
                log('All minimum requirements met');
            } else {
                reqEl.innerHTML = `<div style="background: #ffebee; padding: 15px; border-radius: 4px; color: #c62828;">‚ùå Missing required features: ${missing.join(', ')}</div>`;
                log(`Missing required features: ${missing.join(', ')}`, 'error');
            }

            // Display feature grid
            const featuresEl = document.getElementById('features');
            featuresEl.innerHTML = Object.entries(features).map(([name, supported]) => `
                <div class="feature-item">
                    <div class="feature-name">${name}</div>
                    <span class="feature-status status-${supported ? 'supported' : 'not-supported'}">
                        ${supported ? '‚úì Supported' : '‚úó Not Supported'}
                    </span>
                </div>
            `).join('');

            const supportedCount = Object.values(features).filter(Boolean).length;
            log(`Feature detection complete: ${supportedCount}/${Object.keys(features).length} supported`);
        }

        // Check storage quota
        async function checkStorageQuota() {
            const quotaEl = document.getElementById('storage-quota');

            if (!navigator.storage || !navigator.storage.estimate) {
                quotaEl.innerHTML = '<div>Storage Manager API not available</div>';
                return;
            }

            try {
                const estimate = await navigator.storage.estimate();
                const usage = estimate.usage || 0;
                const quota = estimate.quota || 0;
                const percentage = quota > 0 ? (usage / quota) * 100 : 0;
                const available = quota - usage;

                quotaEl.innerHTML = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Quota</div>
                            <div class="stat-value">${(quota / 1024 / 1024 / 1024).toFixed(2)} <span class="stat-unit">GB</span></div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Used</div>
                            <div class="stat-value">${(usage / 1024 / 1024).toFixed(2)} <span class="stat-unit">MB</span></div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Available</div>
                            <div class="stat-value">${(available / 1024 / 1024).toFixed(2)} <span class="stat-unit">MB</span></div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Usage</div>
                            <div class="stat-value">${percentage.toFixed(1)} <span class="stat-unit">%</span></div>
                        </div>
                    </div>
                    <div class="quota-bar">
                        <div class="quota-fill" style="width: ${percentage}%">${percentage.toFixed(1)}%</div>
                    </div>
                `;

                log(`Storage quota: ${(available / 1024 / 1024).toFixed(2)}MB available`);
            } catch (error) {
                quotaEl.innerHTML = `<div>Error checking storage quota: ${error.message}</div>`;
                log(`Error checking storage quota: ${error.message}`, 'error');
            }
        }

        // Performance benchmarks
        window.runPerformanceBenchmarks = async function() {
            log('Starting performance benchmarks...');
            const resultsEl = document.getElementById('performance-results');
            resultsEl.innerHTML = '<div>Running benchmarks...</div>';

            const results = [];

            // SHA-1 hashing benchmark
            try {
                const data = new TextEncoder().encode('test data\n'.repeat(1000));
                const start = performance.now();
                const iterations = 1000;

                for (let i = 0; i < iterations; i++) {
                    await crypto.subtle.digest('SHA-1', data);
                }

                const duration = performance.now() - start;
                const avgTime = duration / iterations;
                results.push({
                    operation: 'SHA-1 Hashing',
                    avgTime,
                    target: 1,
                    unit: 'ms'
                });
                log(`SHA-1 hashing: ${avgTime.toFixed(3)}ms average`);
            } catch (error) {
                log(`SHA-1 benchmark failed: ${error.message}`, 'error');
            }

            // IndexedDB write benchmark
            if (typeof indexedDB !== 'undefined') {
                try {
                    const dbName = 'perf-test-' + Date.now();
                    const start = performance.now();

                    await new Promise((resolve, reject) => {
                        const request = indexedDB.open(dbName, 1);
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            db.createObjectStore('data', { keyPath: 'key' });
                        };
                        request.onsuccess = () => {
                            const db = request.result;
                            const tx = db.transaction('data', 'readwrite');
                            const store = tx.objectStore('data');

                            for (let i = 0; i < 100; i++) {
                                store.put({ key: `key-${i}`, value: `value-${i}` });
                            }

                            tx.oncomplete = () => {
                                db.close();
                                indexedDB.deleteDatabase(dbName);
                                resolve();
                            };
                            tx.onerror = reject;
                        };
                        request.onerror = reject;
                    });

                    const duration = performance.now() - start;
                    results.push({
                        operation: 'IndexedDB Write (100 items)',
                        avgTime: duration,
                        target: 100,
                        unit: 'ms'
                    });
                    log(`IndexedDB write: ${duration.toFixed(2)}ms for 100 items`);
                } catch (error) {
                    log(`IndexedDB benchmark failed: ${error.message}`, 'error');
                }
            }

            // Display results
            resultsEl.innerHTML = `
                <table class="performance-table">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Average Time</th>
                            <th>Target</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${results.map(r => {
                            const status = r.avgTime <= r.target ? 'good' : r.avgTime <= r.target * 2 ? 'warning' : 'bad';
                            const statusText = r.avgTime <= r.target ? '‚úì Excellent' : r.avgTime <= r.target * 2 ? '‚ö† Acceptable' : '‚úó Slow';
                            return `
                                <tr>
                                    <td>${r.operation}</td>
                                    <td>${r.avgTime.toFixed(2)} ${r.unit}</td>
                                    <td>&lt; ${r.target} ${r.unit}</td>
                                    <td class="performance-${status}">${statusText}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            log('Performance benchmarks complete');
        };

        window.clearPerformanceData = function() {
            document.getElementById('performance-results').innerHTML = '';
            log('Performance data cleared');
        };

        // Generate recommendations
        async function generateRecommendations() {
            const features = await checkFeatures();
            const browser = detectBrowser();
            const recommendations = [];

            // Storage recommendation
            if (features['OPFS']) {
                recommendations.push({
                    title: 'Use OPFS for Best Performance',
                    message: 'Your browser supports OPFS (Origin Private File System), which provides the best file system performance. Use storage: "opfs" when initializing repositories.'
                });
            } else if (features['IndexedDB']) {
                recommendations.push({
                    title: 'Use IndexedDB Storage',
                    message: 'OPFS is not available. IndexedDB is recommended for your browser. Use storage: "indexeddb" when initializing repositories.'
                });
            }

            // Mobile recommendations
            if (navigator.userAgent.includes('Mobile') || navigator.userAgent.includes('iPhone')) {
                recommendations.push({
                    title: 'Mobile Browser Detected',
                    message: 'Mobile browsers have limited storage quotas. Consider implementing shallow clones (depth parameter) and aggressive cache cleanup.'
                });
            }

            // Safari-specific
            if (browser.name === 'Safari') {
                recommendations.push({
                    title: 'Safari Storage Limitations',
                    message: 'Safari has more restrictive storage quotas than Chrome or Firefox. Monitor storage usage carefully and request persistent storage early.'
                });
            }

            // Display recommendations
            const recEl = document.getElementById('recommendations');
            if (recommendations.length === 0) {
                recEl.innerHTML = '<div>No specific recommendations for your browser.</div>';
            } else {
                recEl.innerHTML = recommendations.map(rec => `
                    <div class="recommendation">
                        <h3>${rec.title}</h3>
                        <p>${rec.message}</p>
                    </div>
                `).join('');
            }
        }

        // Initialize
        async function init() {
            log('Initializing browser feature detection demo...');
            displayBrowserInfo();
            await displayFeatures();
            await checkStorageQuota();
            await generateRecommendations();
            log('Initialization complete. Ready to run benchmarks.');
        }

        init();
    </script>
</body>
</html>
